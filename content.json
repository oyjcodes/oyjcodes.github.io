{"meta":{"title":"oyjcodes","subtitle":"待我代码编成，娶你为妻可好...","description":null,"author":"oyjcodes","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-07-31T03:31:28.181Z","updated":"2020-07-31T03:31:28.181Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-31T03:30:55.711Z","updated":"2020-07-31T03:30:55.711Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"charles原理解析","slug":"charles原理解析","date":"2020-09-14T14:23:15.000Z","updated":"2020-09-14T15:31:44.606Z","comments":true,"path":"2020/09/14/charles原理解析/","link":"","permalink":"http://yoursite.com/2020/09/14/charles%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"avatar 初探Charles的抓包原理1最近接手的小需求需要使用到抓包工具，发现类似Charles这样的抓包工具，对于程序员的日常开发是必不可少的； HTTPS的安全性对于HTTPS的分析可见上篇博客：https://oyjcodes.github.io/2020/09/13/%E6%B5%85%E5%B0%9DHTTPS%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/ Charles抓HTTPS包原理当使用者还没有在手机上安装Charles根证书且没有设置为信任时，此时使用Charles抓包HTTPS的情况如下：正常情况下，得到的结果都是，这是因为我们前面讲的HTTPS的安全性的作用； avatar 由上篇博文知HTTPS能有效防止中间人攻击，那么Charles是如何截取HTTPS包的呢？ 这里最为重要的一步就是事先在客户端安装了Charles根证书 接下来Charles需要做的事情是双向伪装：对服务端伪装成客户端，对客户端伪装成服务端 avatar 12对服务端伪装成客户端：截获真实客户端的HTTPS请求，伪装客户端向真实服务端发送HTTPS请求对客户端伪装成服务端：接受真实服务器响应，用Charles自己的证书伪装服务端向真实客户端发送数据内容 HTTPS不是可以避免证书被篡改掉包么?为什么手机安装了Charles根证书后就能正常抓包呢?其实Charles做的就是针对HTTPS的通信双方身份的真实性进行处理； 12345678910111213141516171819当客户端和服务器建立连接时，Charles会拦截到服务器返回的证书（服务器公钥）然后动态生成一张伪造证书（Charles公钥&#x2F;假公钥）发送给客户端客户端收到Charles证书后，进行验证；因为之前我们手机设置了信任，所以验证通过；（只要手机不信任这种证书，HTTPS还是能确保安全的）客户端生成会话密钥，使用Charles证书对会话密钥进行加密再传输给服务器Charles拦截到客户端传输的数据，使用自己的Charles私钥进行解密得到会话密钥连接成功后，客户端和服务器通信，客户端对传输的数据使用会话密钥加密并使用公钥对数据摘要进行数字签名，一同传输给服务器；Charles拦截到通信的数据，使用之前获得的会话密钥解密就能得到原始数据；Charles同样也能篡改通信的数据：将篡改后的数据重新加密并重新生成摘要并使用之前获得的公钥进行数字签名，替换原本的签名，再传输给服务器；服务器收取到数据，按正常流程解密验证；服务器返回响应数据时，Charles也是类似拦截过程","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"}]},{"title":"lombok之Builder注解和建造者模式","slug":"lombok之Builder注解和建造者模式","date":"2020-09-10T07:07:45.000Z","updated":"2020-09-10T11:16:09.449Z","comments":true,"path":"2020/09/10/lombok之Builder注解和建造者模式/","link":"","permalink":"http://yoursite.com/2020/09/10/lombok%E4%B9%8BBuilder%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"@Builder注解的使用使用Lombok的@Builder注解修饰类123456789@Data@Builderpublic class Product &#123; private int id; private String name;&#125; 在IDEA中使用建造者模式创建User对象123456@Test public void test()&#123; Product product = Product.builder() .id(1) .name(\"oyj\").build(); &#125; 编译之后的Product.class文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class Product &#123; private int id; private String name; Product(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return this.id; &#125; public String getName() &#123; return this.name; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public boolean equals(Object o) &#123; if (o == this) &#123; return true; &#125; else if (!(o instanceof Product)) &#123; return false; &#125; else &#123; Product other = (Product)o; if (!other.canEqual(this)) &#123; return false; &#125; else if (this.getId() != other.getId()) &#123; return false; &#125; else &#123; Object this$name = this.getName(); Object other$name = other.getName(); if (this$name == null) &#123; if (other$name != null) &#123; return false; &#125; &#125; else if (!this$name.equals(other$name)) &#123; return false; &#125; return true; &#125; &#125; &#125; protected boolean canEqual(Object other) &#123; return other instanceof Product; &#125; public int hashCode() &#123; int PRIME = true; int result = 1; int result = result * 59 + this.getId(); Object $name = this.getName(); result = result * 59 + ($name == null ? 43 : $name.hashCode()); return result; &#125; public String toString() &#123; return \"Product(id=\" + this.getId() + \", name=\" + this.getName() + \")\"; &#125; //下列代码是根据@Builder注解生成的 public static Product.ProductBuilder builder() &#123; return new Product.ProductBuilder(); &#125; //静态内部类 public static class ProductBuilder &#123; private int id; private String name; ProductBuilder() &#123; &#125; public Product.ProductBuilder id(int id) &#123; this.id = id; return this; &#125; public Product.ProductBuilder name(String name) &#123; this.name = name; return this; &#125; public Product build() &#123; return new Product(this.id, this.name); &#125; public String toString() &#123; return \"Product.ProductBuilder(id=\" + this.id + \", name=\" + this.name + \")\"; &#125; &#125;&#125; 构建的步骤123451. 通过Product中的静态方法创建ProductBuilder对象（用于后续构建Product）：builder //Product.ProductBuilder builder = Product.builder()2. 设置Product需要的属性值（链式返回ProductBuilder对象） // builder = builder.id().name() 3. 通过ProductBuilder对象的 build()方法，构建Product对象并返回（其实就是将builder中与Product同样的属性值去构造Product对象） // Product product = builder.build() 传统Builder模式UML类图 avatar 1234Director（导演角色），调用具体构造者创建产品对象，他是负责从客户端传来指令交给具体干活的类。Builder （抽象建造者），没有具体的业务意义，就是抽象出具体构造者的方法，简单说就是为了多态。ConcreteBuilder（具体构造者），苦力，实打实的把零件造好，组装好Product（产品） 产品类123456789101112131415/** * @title: User * @description: 产品类 */public class Product &#123; private int id; private String name; public Product(int id, String name) &#123; this.id = id; this.name = name; &#125;&#125; 抽象建造者123456789101112131415161718192021222324/** * @title: Builder * @description: 抽象建造者 */public abstract class Builder &#123; protected int id; protected String name; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; /** * @Description: 构建产品 * @param * @return */ public abstract Product build();&#125; 具体建造者1234567891011121314151617181920/** * @title: ConcreteBuilder * @description: 具体建造者 */public class ConcreteBuilder extends Builder&#123; @Override public void setId(int id) &#123; super.setId(id); &#125; @Override public void setName(String name) &#123; super.setName(name); &#125; @Override public Product build() &#123; return new Product(id,name); &#125;&#125; 导演类123456789101112/** * @title: Director * @description: 导演类 */public class Director &#123; public Product getProduct()&#123; Builder builder = new ConcreteBuilder(); builder.setId(1); builder.setName(\"apple\"); return builder.build(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"http://yoursite.com/tags/lombok/"}]},{"title":"打怪之流式编程：Stream（一）","slug":"Stream技能","date":"2020-09-08T02:58:52.000Z","updated":"2020-09-08T09:20:03.648Z","comments":true,"path":"2020/09/08/Stream技能/","link":"","permalink":"http://yoursite.com/2020/09/08/Stream%E6%8A%80%E8%83%BD/","excerpt":"","text":"java中的流式编程——Stream API1Stream不是集合元素，它不是数据结构并不保存数据，它更像一个高级版本的 Iterator,单向且不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 流的构成当我们使用一个流的时候，通常包括三个基本步骤： 获取一个数据源（source） 数据转换: 执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链一样排列，变成一个管道。 终止操作 1、操作的数据源12345678910111213public static List&lt;Employee&gt; generateListData() &#123; return Arrays.asList(new Employee(\"Matt\", 5000, \"New York\"), new Employee(\"Steve\", 6000, \"London\"), new Employee(\"Steve\", 7800, \"Shanghai\"), new Employee(\"Carrie\", 10000, \"New York\"), new Employee(\"Peter\", 7000, \"New York\"), new Employee(\"Alec\", 6000, \"London\"), new Employee(\"Sarah\", 8000, \"London\"), new Employee(\"Rebecca\", 4000, \"New York\"), new Employee(\"Pat\", 20000, \"New York\"), new Employee(\"Tammy\", 9000, \"New York\"), new Employee(\"Fred\", 15000, \"Tokyo\")); &#125; 2.1、过滤（筛选与切片） 方法 示意 filter 接收Lambda表达式，从流中排除某些元素 distinct 返回包含唯一元素的流（唯一性取决于元素相等的实现方式）,例如通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit 截断流，使其元素不超过给定数量 skip 返回一个丢弃前n个元素的流 avatar 1234567891011121314151617181920212223242526272829303132/** * @Description: 过滤工资大于8000的所有员工 * @param * @return */ @Test public void test1()&#123; List&lt;Employee&gt; results = generateListData(); //old List&lt;Employee&gt; list = new ArrayList&lt;&gt;(); for (Employee employee : results)&#123; if(employee.getSalary() &gt; 8000)&#123; list.add(employee); &#125; &#125; System.out.println(list); //new 1 List&lt;Employee&gt; collect = results.stream().filter(employee -&gt; (employee.getSalary() &gt; 8000)) .collect(Collectors.toList()); System.out.println(collect); //new 2 List&lt;Employee&gt; collect1 = results.stream().filter(employee -&gt; &#123; if (employee.getSalary() &gt; 8000) &#123; return true; &#125; else &#123; return false; &#125; &#125;).collect(Collectors.toList()); System.out.println(collect1); &#125; 123456[ Employee(name&#x3D;Carrie pit, salary&#x3D;10000, office&#x3D;New York), Employee(name&#x3D;Pat, salary&#x3D;20000, office&#x3D;New York), Employee(name&#x3D;Tammy, salary&#x3D;9000, office&#x3D;New York), Employee(name&#x3D;Fred, salary&#x3D;15000, office&#x3D;Tokyo)]] 2.2、映射 方法 示意 应用 map 应用于单个元素，将其映射成新元素（传递一个函数对象作为方法，把流中的元素转换成另一种类型） map生成的是个一对一映射，比较常用 flatMap 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 flatMap生成一个一对多映射 avatar 12345678910111213141516171819202122232425262728@Test public void test2() &#123; List&lt;Employee&gt; results = generateListData(); //old List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (Employee employee : results)&#123; if(employee.getSalary() &gt; 8000)&#123; list.add(employee.getName()); &#125; &#125; System.out.println(list); //new 1 List&lt;String&gt; collect = results.stream() //过滤 .filter(employee -&gt; (employee.getSalary() &gt; 8000)) //转化映射 .map(employee -&gt; employee.getName()).collect(Collectors.toList()); System.out.println(collect); //new 2 List&lt;String&gt; collect1 = results.stream() //过滤 .filter(employee -&gt; (employee.getSalary() &gt; 8000)) //转化映射 .map(Employee::getName).collect(Collectors.toList()); System.out.println(collect1); &#125; 1[Carrie pit, Pat, Tammy, Fred] avatar 1234567891011121314151617181920212223242526272829303132333435363738 /** * @Description: map 和 flatMap * @param * @return */@Test public void test3() &#123; List&lt;Employee&gt; results = generateListData(); //返回类型不一样 List&lt;String&gt; collect = results.stream(). //每一个对象映射为名字(名字数组进一步处理为流对象) flatMap(employee -&gt; Arrays.stream(employee.getName().split(\" \"))) .collect(Collectors.toList()); System.out.println(collect); List&lt;Stream&lt;String&gt;&gt; collect1 = results.stream(). map(employee -&gt; Arrays.stream(employee.getName().split(\" \"))) .collect(Collectors.toList()); System.out.println(collect1); //-------------------------------------------------------- //实现1 List&lt;String&gt; collect2 = results.stream() .map(employee -&gt; (employee.getName().split(\" \"))) .flatMap(Arrays::stream) .collect(Collectors.toList()); System.out.println(collect2); //实现1 List&lt;String&gt; collect3 = results.stream() //返回多个list .map(employee -&gt; (employee.getName().split(\" \"))) //将流中的每个值都换成另一个流，然后把所有流连接成一个流 .flatMap(str -&gt; Arrays.asList(str).stream()) .collect(Collectors.toList()); System.out.println(collect3); &#125; 1map和flatMap的区别：flatMap的可以处理更深层次的数据，入参为多个list，结果可以返回为一个list，而map是一对一的，入参是多个list，结果返回必须是多个list。通俗的说，如果入参都是对象，那么flatMap可以操作对象里面的对象，而map只能操作第一层。 3、Collectors（返回流操作完之后的结果）1collect方法是一个结束操作，它可以使流里面的所有元素聚集到汇总结果。传递给collect方法参数是一个java.util.stream.Collector类型的对象。Collector对象实际上定义了一个如何把流中的元素聚集到最终结果的方法。(?).collect(Collectors.?) 方法 示意 toList 转化为List toSet 转化为Set toMap 转化为Map 1234567891011121314151617181920212223242526@Test public void test4()&#123; List&lt;Employee&gt; employees = generateListData(); //toList List&lt;String&gt; collect = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); System.out.println(collect); //toSet Set&lt;String&gt; collect1 = employees.stream() .map(Employee::getName) .collect(Collectors.toSet()); System.out.println(collect1); //toMap Map&lt;String, Employee&gt; map1 = employees.stream() .collect(Collectors.toMap((key-&gt;key.getName()), (Person -&gt; Person))); Map&lt;String, Integer&gt; map2 = employees.stream() .collect(Collectors.toMap((key-&gt;key.getName()), (Person -&gt; Person.getSalary()))); map1.forEach((key,value) -&gt; System.out.println(\"key:\" + key + \" value:\"+ value)); map2.forEach((key,value) -&gt; System.out.println(\"key:\" + key + \" value:\"+ value)); &#125; Optional12Optional类主要解决的问题是臭名昭著的空指针异常（NullPointerException）—— 每个Java程序员都非常了解的异常。本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。 方法 示意 Optional.of(T) T为非空，否则初始化报错。你应该明确对象T不为null的时候使用 of() Optional.ofNullable(T) T为任意，可以为空。如果对象T即可能是null也可能是非null,你就应该使用ofNullable()方法： isPresent() 等价于 !=null ifPresent(T) T可以是一段lambda表达式 ，或者其他代码，非空则执行 12345678910111213141516171819202122232425262728293031323334@Test public void test5()&#123; Employee employee = new Employee(); employee.setName(\"oyj\"); //of(T),T为非空值 Optional&lt;Employee&gt; emp = Optional.of(employee); System.out.println(emp.isPresent()?emp.get():\"emp对象为空\"); //ofNullable(T),T为任意值 Optional&lt;String&gt; name = Optional.ofNullable(employee.getName()); //name!=null输出name;否则输出\"name值是空的\" System.out.println(name.isPresent()?name.get():\"name值是空的\"); //如果不为空则打印,ifPresent(T),T可以是一段lambda表达式,或者其他代码，非空则执行 Optional.ofNullable(\"oyj\").ifPresent(x-&gt;&#123; System.out.println(x+\" isPresent\"); &#125;); //在optional为空值的情况下orElse和orElseGet都会执行， //当optional不为空时，orElse()方法仍然执行,orElseGet()不会执行。 //在执行较密集的调用时，比如调用Web服务或数据查询，这个差异会对性能产生重大影响。 //如果为null，则返回指定的字符串 System.out.println(Optional.ofNullable(null).orElse(\"为空\")); System.out.println(Optional.ofNullable(\"oyj\").orElse(\"为空\")); //如果为null，则返回指定的方法 System.out.println(Optional.ofNullable(null).orElseGet(()-&gt;&#123; return \"hahahah\"; &#125;)); System.out.println(Optional.ofNullable(1).orElseGet(()-&gt;&#123; return 2; &#125;)); &#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Stream","slug":"Stream","permalink":"http://yoursite.com/tags/Stream/"}]},{"title":"挑战Redis系列(1)——协议","slug":"Redis系列1","date":"2020-09-07T15:29:56.000Z","updated":"2020-09-09T07:56:54.588Z","comments":true,"path":"2020/09/07/Redis系列1/","link":"","permalink":"http://yoursite.com/2020/09/07/Redis%E7%B3%BB%E5%88%971/","excerpt":"","text":"1RESP(REdis Serialization Protocol),也就是专门为redis设计的一套序列化协议. 这个协议其实在redis的1.2版本时就已经出现了,但是到了redis2.0才最终成为redis通讯协议的标准 Redis通讯协议（TCP层） 特点 为什么 二进制安全的 不需要处理从一个进程传输到另一个进程的批量数据，因为它使用前缀长度来传输批量数据。 可读性高 简单 快速解析 简单 易于实现 简单 1注意:此处概述的协议仅用于客户端 - 服务器通信。 Redis Cluster使用不同的二进制协议，以便在节点之间交换消息。 RESP数据类型Redis协议将传输的结构数据分为5种类型，第一个字节的符号来表示不同的数据类型,单元结束时统一加上回车换行符号 \\r\\n。 类型 标识符 形式 例子 简单字符串（simple string） + 放在第一个字节 “+OK\\r\\n” 错误消息（error） - 放在第一个字节 “-ERR unknown command ‘foobar’\\r\\n” 长字符串（bulk string）&lt;512M $ 放在第一个字节，后面跟字符串的长度 “$0\\r\\n” –$后面的0表示这是一个空字符串 整型数字（integer） : 放在第一个字节，后面跟整形的字符串 “:1000\\r\\n” 数组（arrays） * 放在第一个字节，后面跟数组的长度 “0\\r\\n” –后面的0表示表示空的数组 简单字符串12simple string 的第一个字节是个&quot;+&quot;(加号), 后面接着的是字符串的内容, 最后以CRLF(\\r\\n)结尾.例如:&quot;+hello world\\r\\n&quot; 错误消息12error其实和string是类似的, 但是RESP为了能让不同客户端把这种error和正常的返回结果区分开来对待 (例如redis返回error的话,就抛出异常),特意多设计了这个数据类型。error类型的第一个字节是&quot;-&quot;(减号), 后面接着的是错误的信息, 最后以CRLF(\\r\\n)结尾,例如:-ERR unknown command &#39;sets&#39;\\r\\n&quot; 长字符串1234567本质上也是字符串,跟普通字符串区分开来, 它的第一个字节是&quot;$&quot;(美元符号),紧接着是一个整数,表示字符串的字节数,字节数后面接一个CRLF. CRLF后面是字符串的内容, 最后以一个CRLF结尾. 例如:&quot;$0\\r\\n&quot; --$后面的0表示这是一个空字符串&quot;$-1\\r\\n&quot; -- $后面的-1表示这是一个null字符串,Null Bulk String要求客户端返回空对象,而不能简单地返回个空字符串&quot;$\\r\\n6ABCDEF\\r\\n&quot; -- ABCDEF是6个字节,所以$后面是6 整型数字“:29\\r\\n” 数组1234567891011121314151617第一个字节是&quot;*&quot;(星号), 紧接着后面是一个数字,表示这个数组的长度,数字后面是一个CRLF. 需要注意的是这个CRLF之后才是数组的真正内容, 而且数组内容可以是任意类型, 包括arrays和bulk string, 每个元素也要以CRLF结尾. 最后以CRLF(\\r\\n)结尾. 例如:&quot;*0\\r\\n&quot; --*后面的0表示表示空的数组&quot;*-1\\r\\n&quot; --*后面的-1表示表示是null数组&quot;*5\\r\\n -- *5表示这是一个拥有5个元素的数组+bar\\r\\n -- 第1个元素是简单的字符串-unknown command\\r\\n -- 第2个元素是个异常:3\\r\\n -- 第3个元素是个整数$3\\r\\n -- 第4个元素是长度为3个字节的长字符串foofoo\\r\\n -- 第4个元素的内容*3\\r\\n -- 第5个元素又是个数组:1\\r\\n -- 第5个元素数组的第1元素:2\\r\\n -- 第5个元素数组的第2元素:3\\r\\n -- 第5个元素数组的第3元素&quot; request-response模型121. redis发送一个命令到服务端（一般组装成bulk string的数组）, 然后阻塞在socket.read()方法, 等待服务端的返回2. 服务端收到一个命令, 处理完成后将数据发送回去给客户端 redis的大部分命令都是使用这种request-response模型进行通讯, 除了以下两种特殊的情况 121. pipeline模式. 在pipeline模式下, 客户端可能会把多个命令收集在一起, 然后一并发送给服务端, 最后等待服务端把所有命令的执行响应一并发送回来2. pub&#x2F;sub, 发布订阅模式下, redis客户端只需要发送一次订阅命令 测试和验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @title: RedisClient * @description: 撸一个简单的客户端 */public class RedisClient &#123; private static Socket socket; private static OutputStream write; private static InputStream read; public static void main(String[] args) throws IOException &#123; socket = new Socket(\"127.0.0.1\",6379); write = socket.getOutputStream(); read = socket.getInputStream(); Scanner scan = new Scanner(System.in); // 判断是否还有输入 while (scan.hasNextLine()) &#123; String str = scan.nextLine(); // 构造协议 String commannd = buildCommand(str); System.out.println(\"发送命令为：\\r\\n\" + commannd); String result = sendCommand(commannd); System.out.println(\"响应命令为：\" + result); &#125; scan.close(); &#125; /** * @Description: 发送协议到客户端 * @param * @return */ private static String sendCommand(String command) throws IOException &#123; write.write(command.getBytes()); byte[] bytes = new byte[1024]; read.read(bytes); return new String(bytes,\"UTF-8\"); &#125; /** * @Description: 构建RESP协议 * @param * @return */ private static String buildCommand(String str) &#123; if (!StringUtils.isEmpty(str)) &#123; String[] strs = str.split(\" \"); StringBuilder builder = new StringBuilder(); builder.append(\"*\").append(strs.length).append(\"\\r\\n\"); for (String str1 : strs) &#123; builder.append(\"$\").append(str1.length()).append(\"\\r\\n\"); builder.append(str1).append(\"\\r\\n\"); &#125; return builder.toString(); &#125; return null; &#125;&#125; 运行结果 avatar avatar avatar","categories":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Git基础","slug":"Git基础","date":"2020-09-04T09:03:45.000Z","updated":"2020-09-08T09:52:46.666Z","comments":true,"path":"2020/09/04/Git基础/","link":"","permalink":"http://yoursite.com/2020/09/04/Git%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Git基础一 avatar 四个区五个状态 —— 五种状态间的撤销操作 avatar 区 名称 工作区 Working Area 暂存区 Stage 本地仓库 Local Repository 远程仓库 Remote Repository 状态 名称 未修改 UnModified 已修改 Modified 已暂存 Staged 已提交 Remote Repository 1. 已经修改，但还未暂存（还没有执行 git add） 操作 含义 git diff 检查的是工作区与暂存区之间的差异 git checkout 撤销项目下所有的修改 git clean -f 撤销新增的文件 git clean -df 撤销新增的文件和文件夹 avatar 2. 已经修改，但还未提交（还没有执行 git commit） 操作 含义 git diff –cached 检查的是暂存区和本地仓库的差异 git reset 暂存区的修改恢复到工作区,即当前暂存区不存在最新的内容 git reset –soft 与git reset等价，回到已修改状态，修改的内容仍然在工作区中 git reset –hard 回到未修改状态，清空暂存区和工作区 必须先执行git reset = git reset –soft，否则无法撤销修改 avatar avatar 通过git reset + git checkout 命令-&gt;取消了工作区的修改，此时工作区的内容回退到了修改之前（hello world -&gt; 123456uuu12） avatar avatar 回到未修改状态，清空暂存区和工作区，此时工作区的内容回退到了修改之前（123 -&gt; hello word123），彻底还原到上一次提交的状态且无法找回1git reset --hard &#x3D; git reset + git checkout avatar 清空（不是删除所有内容，而是回退到修改之前的暂存区内容） avatar 3. 已提交，未推送执行完commit之后，会在仓库中生成一个版本号(hash值)，标志这次提交。之后任何时候，都可以借助这个hash值回退到这次提交。 操作 含义 git diff master origin/master 查看本地仓库与本地远程仓库的差异 git reset –hard HEAD^ 回退到本地仓库上一个版本 git reset –hard 回退到任意版本 git reset –soft/git reset 回退且回到已修改状态，修改仍保留在工作区中 4. 已推送到远程 操作 含义 git push -f orgin master 强制覆盖远程分支 git push -f 如果之前已经用 -u 关联过，则可省略分支名 总结1234567首先，先用git status查看下当前状态。git reset可以作用于本地仓库，用于回退&#x2F;前进到任意版本，也可以作用于暂存区，用于撤销暂存区修改。有hard和soft2个参数。soft参数可以省略，soft参数表示撤销的修改仍放在工作区中。git checkout用于撤销删除和修改，git clean用于撤销新增。git diff可以查看工作区、暂存区、仓库之间的修改和差异，参数不同。","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"HashMap源码解析","slug":"HashMap","date":"2019-07-11T03:14:24.000Z","updated":"2020-07-30T14:28:02.183Z","comments":true,"path":"2019/07/11/HashMap/","link":"","permalink":"http://yoursite.com/2019/07/11/HashMap/","excerpt":"","text":"HashMap源码解析 默认的常量 12345678910//创建 HashMap 时未指定初始容量情况下的默认容量 16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//HashMap 的最大容量 2^30 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//HashMap 默认的装载因子,当 HashMap 中元素数量超过容量装载因子时，进行 resize() 操作static final float DEFAULT_LOAD_FACTOR = 0.75f; //链表转红黑树的阈值 static final int TREEIFY_THRESHOLD = 8; //用来确定何时将解决 hash 冲突的红黑树转变为链表static final int UNTREEIFY_THRESHOLD = 6; 存储结构内部包含了一个 Node 类型的数组 table。观察 Node 可以发现table是一个链表 1234567/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */transient Node&lt;K,V&gt;[] table; Node 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 table 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Ndoe. 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//保存节点的hash值 final K key;//保存节点的key值 V value;//保存节点的value值 Node&lt;K,V&gt; next;//指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构 1234567891011121314151617181920212223static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 存储当前节点的父节点 TreeNode&lt;K,V&gt; left; //存储当前节点的左孩子 TreeNode&lt;K,V&gt; right; //存储当前节点的右孩子 TreeNode&lt;K,V&gt; prev; // 存储当前节点的前一个节点 boolean red; // 存储当前节点的颜色（红、黑） TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; HashMap的结构 avatar 拉链法的工作原理1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"K1\", \"V1\");map.put(\"K2\", \"V2\");map.put(\"K3\", \"V3\"); . 新建一个 HashMap，默认大小为 16；. 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。. 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。. 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在&lt;K2,V2&gt; 前面。注意：应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部 查找需要分成两步进行：计算键值对所在的桶；在链表上顺序查找，时间复杂度显然和链表的长度成正比。 put操作12345678910111213141516171819202122232425public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null; &#125; 确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。123static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 12345678910111213private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 1234567891011121314void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125; void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 扩容-基本原理设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。 avatar 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。 12345678void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //键值对的数量size大于threshold时进行扩容操作 if (size++ &gt;= threshold) //扩容使用resize()实现 resize(2 * table.length);&#125; 扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。 123456789101112131415161718192021222324252627282930void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor);&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125;&#125; 扩容-重新计算桶下标在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：capacity : 00010000new capacity : 00100000对于一个 Key， 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；如果为 1，那么得到的结果为原来的结果 +16。 计算数组容量HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。 先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到： 123mask |&#x3D; mask &gt;&gt; 1 11011000mask |&#x3D; mask &gt;&gt; 2 11111110mask |&#x3D; mask &gt;&gt; 4 11111111 链表转红黑树从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。","categories":[{"name":"集合","slug":"集合","permalink":"http://yoursite.com/categories/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"源码阅读","slug":"源码阅读","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}]},{"title":"java内存模型","slug":"java内存模型","date":"2019-07-10T03:14:24.000Z","updated":"2020-07-30T14:28:02.188Z","comments":true,"path":"2019/07/10/java内存模型/","link":"","permalink":"http://yoursite.com/2019/07/10/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"JAVA内存模型（Jave Memory Model:JMM）一、CPU和内存的交互在计算机中，cpu和内存的交互最为频繁，但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种CPU与内存间的速度不匹配问题情况。cpu和内存的交互大致如下。 avatar 二、多核CPU多级缓存一致性协议MESI多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致性,不让系统数据混乱。这里就引出了一个一致性的协议MESI。CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示): M: 被修改（Modified) 该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。 当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。 E: 独享的（Exclusive) 该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。 同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。 S: 共享的（Shared) 该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。 I: 无效的（Invalid） 该缓存是无效的（可能有其它CPU修改了该缓存行）。 三、什么是JMM？JMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 avatar 四、java内存模型抽象结构图 avatar JMM（java memory model）java内存模型主要目标是定义程序中的变量，（此处所指的变量是实例字段、静态字段等，不包含局部变量和函数参数，因为这两种是线程私有且无法共享）在虚拟机中规定了存储到内存与从内存读取出来的5规则细节，Java 内存模型规定所有变量都存储在主内存中，每条线程还有自己的工作内存，工作内存保存了该线程使用到的变量（主内存副本拷贝），线程对变量的所有操作（读取、赋值）都必须在自己的工作内存中进行而不能直接读写主内存的变量，不同线程之间无法相互直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。 avatar Java 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作，具体如下： lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量从主内存传输到线程的工作内存中，以便随后的 load 动作使用。 load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时执行此操作。 assign（赋值）：作用于工作内存变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要给变量进行赋值的字节码指令时执行此操作。 store（存储）：作用于工作内存变量，把工作内存中一个变量的值传递到主内存中，以便后续 write 操作。 write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的值放入主内存变量中。br avatar 如果要把一个变量从主内存复制到工作内存就必须按顺序执行 read 和 load 操作，从工作内存同步回主内存就必须顺序执行 store 和 write 操作但是 JVM 只要求了操作的顺序而没有要求上述操作必须保证连续性，所以实质执行中 read 和 load 间及 store 和 write 间是可以插入其他指令的。 其实 Java JMM 内存模型是围绕并发编程中原子性、可见性、有序性三个特征来建立的，关于原子性、可见性、有序性的理解如下： 原子性：就是说一个操作不能被打断，要么执行完要么不执行，类似事务操作，Java 基本类型数据的访问大都是原子操作，long 和 double 类型是 64 位，在 32 位 JVM 中会将 64 位数据的读写操作分成两次 32 位来处理，所以 long 和 double 在 32 位 JVM 中是非原子操作，也就是说在并发访问时是线程非安全的，要想保证原子性就得对访问该数据的地方进行同步操作，譬如 synchronized 等。 可见性：就是说当一个线程对共享变量做了修改后其他线程可以立即感知到该共享变量的改变，从 Java 内存模型我们就能看出来多线程访问共享变量都要经过线程工作内存到主存的复制和主存到线程工作内存的复制操作，所以普通共享变量就无法保证可见性了；Java 提供了 volatile 修饰符来保证变量的可见性，每次使用 volatile 变量都会主动从主存中刷新，除此之外 synchronized、Lock、final 都可以保证变量的可见性。 有序性：就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，所以在并发中我们必须要想办法保证并发代码的有序性；在 Java 里可以通过 volatile 关键字保证一定的有序性，还可以通过 synchronized、Lock 来保证有序性，因为 synchronized、Lock 保证了每一时刻只有一个线程执行同步代码相当于单线程执行，所以自然不会有有序性的问题；除此之外 Java 内存模型通过 happens-before 原则如果能推导出来两个操作的执行顺序就能先天保证有序性，否则无法保证，关于 happens-before 原则可以查阅相关资料。 所以说如果想让 Java 并发程序正确的执行必须保证原子性、有序性、可见性，只要三者中有任意一个不满足并发都无法正确执行。","categories":[{"name":"java技术","slug":"java技术","permalink":"http://yoursite.com/categories/java%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"java内存","slug":"java内存","permalink":"http://yoursite.com/tags/java%E5%86%85%E5%AD%98/"}]},{"title":"hexo的使用","slug":"hexo的使用","date":"2018-11-07T07:55:28.000Z","updated":"2020-09-04T09:10:20.608Z","comments":true,"path":"2018/11/07/hexo的使用/","link":"","permalink":"http://yoursite.com/2018/11/07/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Hexo部署命令的使用 在source_posts文件夹下创建一个新的md文件1hexo new &quot;***&quot; 在public文件夹下面生成静态文件1hexo generate 或者 hexo g 启动本地服务，先观察部署的md文件是否生效1hexo server 或者 hexo s 观察无误后，可以进行网站的部署1hexo deploy 或者 hexo d public静态文件的清理命令1hexo clean","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/categories/Redis/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/categories/%E9%9B%86%E5%90%88/"},{"name":"java技术","slug":"java技术","permalink":"http://yoursite.com/categories/java%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"},{"name":"lombok","slug":"lombok","permalink":"http://yoursite.com/tags/lombok/"},{"name":"Stream","slug":"Stream","permalink":"http://yoursite.com/tags/Stream/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"源码阅读","slug":"源码阅读","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"java内存","slug":"java内存","permalink":"http://yoursite.com/tags/java%E5%86%85%E5%AD%98/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"http://yoursite.com/tags/Blog/"}]}