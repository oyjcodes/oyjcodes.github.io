<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oyjcodes</title>
  
  <subtitle>待我代码编成，娶你为妻可好...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-14T15:38:28.946Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>oyjcodes</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>charles原理解析</title>
    <link href="http://yoursite.com/2020/09/14/charles%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/09/14/charles%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-09-14T14:23:15.000Z</published>
    <updated>2020-09-14T15:38:28.946Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><h2 id="初探Charles的抓包原理"><a href="#初探Charles的抓包原理" class="headerlink" title="初探Charles的抓包原理"></a>初探Charles的抓包原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近接手的小需求需要使用到抓包工具，发现类似Charles这样的抓包工具，对于程序员的日常开发是必不可少的；</span><br></pre></td></tr></table></figure><h3 id="HTTPS的安全性"><a href="#HTTPS的安全性" class="headerlink" title="HTTPS的安全性"></a>HTTPS的安全性</h3><p>对于HTTPS的分析可见上篇博客：<br> <a href="https://oyjcodes.github.io/2020/09/13/浅尝HTTPS通信协议/" target="_blank" rel="noopener">https://oyjcodes.github.io/2020/09/13/浅尝HTTPS通信协议/</a></p><h3 id="Charles抓HTTPS包原理"><a href="#Charles抓HTTPS包原理" class="headerlink" title="Charles抓HTTPS包原理"></a>Charles抓HTTPS包原理</h3><p>当使用者还没有在手机上安装Charles根证书且没有设置为信任时，此时使用Charles抓包HTTPS的情况如下：<br>正常情况下，得到的结果都是<unknown>，这是因为我们前面讲的HTTPS的安全性的作用；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><p>由上篇博文知HTTPS能有效防止中间人攻击，那么Charles是如何截取HTTPS包的呢？</p><ol><li><p>这里最为重要的一步就是事先在客户端安装了Charles根证书</p></li><li><p>接下来Charles需要做的事情是双向伪装：对服务端伪装成客户端，对客户端伪装成服务端</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对服务端伪装成客户端：截获真实客户端的HTTPS请求，伪装客户端向真实服务端发送HTTPS请求</span><br><span class="line">对客户端伪装成服务端：接受真实服务器响应，用Charles自己的证书伪装服务端向真实客户端发送数据内容</span><br></pre></td></tr></table></figure><h3 id="HTTPS不是可以避免证书被篡改掉包么-为什么手机安装了Charles根证书后就能正常抓包呢"><a href="#HTTPS不是可以避免证书被篡改掉包么-为什么手机安装了Charles根证书后就能正常抓包呢" class="headerlink" title="HTTPS不是可以避免证书被篡改掉包么?为什么手机安装了Charles根证书后就能正常抓包呢?"></a>HTTPS不是可以避免证书被篡改掉包么?为什么手机安装了Charles根证书后就能正常抓包呢?</h3><p>其实Charles做的就是针对HTTPS的通信双方身份的真实性进行处理；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">当客户端和服务器建立连接时，Charles会拦截到服务器返回的证书（服务器公钥）</span><br><span class="line"></span><br><span class="line">然后动态生成一张伪造证书（Charles公钥&#x2F;假公钥）发送给客户端</span><br><span class="line"></span><br><span class="line">客户端收到Charles证书后，进行验证；因为之前我们手机设置了信任，所以验证通过；（只要手机不信任这种证书，HTTPS还是能确保安全的）</span><br><span class="line"></span><br><span class="line">客户端生成会话密钥，使用Charles证书对会话密钥进行加密再传输给服务器</span><br><span class="line"></span><br><span class="line">Charles拦截到客户端传输的数据，使用自己的Charles私钥进行解密得到会话密钥</span><br><span class="line"></span><br><span class="line">连接成功后，客户端和服务器通信，客户端对传输的数据使用会话密钥加密并使用公钥对数据摘要进行数字签名，一同传输给服务器；</span><br><span class="line"></span><br><span class="line">Charles拦截到通信的数据，使用之前获得的会话密钥解密就能得到原始数据；</span><br><span class="line"></span><br><span class="line">Charles同样也能篡改通信的数据：将篡改后的数据重新加密并重新生成摘要并使用之前获得的公钥进行数字签名，替换原本的签名，再传输给服务器；</span><br><span class="line"></span><br><span class="line">服务器收取到数据，按正常流程解密验证；</span><br><span class="line"></span><br><span class="line">服务器返回响应数据时，Charles也是类似拦截过程</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="抓包" scheme="http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>lombok之Builder注解和建造者模式</title>
    <link href="http://yoursite.com/2020/09/10/lombok%E4%B9%8BBuilder%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/09/10/lombok%E4%B9%8BBuilder%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-09-10T07:07:45.000Z</published>
    <updated>2020-09-10T11:16:09.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Builder注解的使用"><a href="#Builder注解的使用" class="headerlink" title="@Builder注解的使用"></a>@Builder注解的使用</h2><h3 id="使用Lombok的-Builder注解修饰类"><a href="#使用Lombok的-Builder注解修饰类" class="headerlink" title="使用Lombok的@Builder注解修饰类"></a>使用Lombok的@Builder注解修饰类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在IDEA中使用建造者模式创建User对象"><a href="#在IDEA中使用建造者模式创建User对象" class="headerlink" title="在IDEA中使用建造者模式创建User对象"></a>在IDEA中使用建造者模式创建User对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Product product = Product.builder()</span><br><span class="line">               .id(<span class="number">1</span>)</span><br><span class="line">               .name(<span class="string">"oyj"</span>).build();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="编译之后的Product-class文件"><a href="#编译之后的Product-class文件" class="headerlink" title="编译之后的Product.class文件"></a>编译之后的Product.class文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Product(<span class="keyword">int</span> id, String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Product)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Product other = (Product)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getId() != other.getId()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Object <span class="keyword">this</span>$name = <span class="keyword">this</span>.getName();</span><br><span class="line">                Object other$name = other.getName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$name != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$name.equals(other$name)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> Product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> PRIME = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = result * <span class="number">59</span> + <span class="keyword">this</span>.getId();</span><br><span class="line">        Object $name = <span class="keyword">this</span>.getName();</span><br><span class="line">        result = result * <span class="number">59</span> + ($name == <span class="keyword">null</span> ? <span class="number">43</span> : $name.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product(id="</span> + <span class="keyword">this</span>.getId() + <span class="string">", name="</span> + <span class="keyword">this</span>.getName() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下列代码是根据@Builder注解生成的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product.<span class="function">ProductBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product.ProductBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        ProductBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Product.<span class="function">ProductBuilder <span class="title">id</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Product.<span class="function">ProductBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Product(<span class="keyword">this</span>.id, <span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Product.ProductBuilder(id="</span> + <span class="keyword">this</span>.id + <span class="string">", name="</span> + <span class="keyword">this</span>.name + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建的步骤"><a href="#构建的步骤" class="headerlink" title="构建的步骤"></a>构建的步骤</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 通过Product中的静态方法创建ProductBuilder对象（用于后续构建Product）：builder   <span class="comment">//Product.ProductBuilder builder  = Product.builder()</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 设置Product需要的属性值（链式返回ProductBuilder对象）  <span class="comment">// builder = builder.id().name()</span></span><br><span class="line">             </span><br><span class="line"><span class="number">3</span>. 通过ProductBuilder对象的 build()方法，构建Product对象并返回（其实就是将builder中与Product同样的属性值去构造Product对象）  <span class="comment">// Product product = builder.build()</span></span><br></pre></td></tr></table></figure><h2 id="传统Builder模式"><a href="#传统Builder模式" class="headerlink" title="传统Builder模式"></a>传统Builder模式</h2><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Director（导演角色），调用具体构造者创建产品对象，他是负责从客户端传来指令交给具体干活的类。</span><br><span class="line">Builder （抽象建造者），没有具体的业务意义，就是抽象出具体构造者的方法，简单说就是为了多态。</span><br><span class="line">ConcreteBuilder（具体构造者），苦力，实打实的把零件造好，组装好</span><br><span class="line">Product（产品）</span><br></pre></td></tr></table></figure><h3 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: User</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象建造者"><a href="#抽象建造者" class="headerlink" title="抽象建造者"></a>抽象建造者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: Builder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 抽象建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@Description</span>: 构建产品</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体建造者"><a href="#具体建造者" class="headerlink" title="具体建造者"></a>具体建造者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: ConcreteBuilder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 具体建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Product(id,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导演类"><a href="#导演类" class="headerlink" title="导演类"></a>导演类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: Director</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 导演类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        builder.setId(<span class="number">1</span>);</span><br><span class="line">        builder.setName(<span class="string">"apple"</span>);</span><br><span class="line">        <span class="keyword">return</span>  builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Builder注解的使用&quot;&gt;&lt;a href=&quot;#Builder注解的使用&quot; class=&quot;headerlink&quot; title=&quot;@Builder注解的使用&quot;&gt;&lt;/a&gt;@Builder注解的使用&lt;/h2&gt;&lt;h3 id=&quot;使用Lombok的-Builder注解修饰类&quot;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="lombok" scheme="http://yoursite.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>打怪之流式编程：Stream（一）</title>
    <link href="http://yoursite.com/2020/09/08/Stream%E6%8A%80%E8%83%BD/"/>
    <id>http://yoursite.com/2020/09/08/Stream%E6%8A%80%E8%83%BD/</id>
    <published>2020-09-08T02:58:52.000Z</published>
    <updated>2020-09-08T09:20:03.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java中的流式编程——Stream-API"><a href="#java中的流式编程——Stream-API" class="headerlink" title="java中的流式编程——Stream API"></a>java中的流式编程——Stream API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream不是集合元素，它不是数据结构并不保存数据，它更像一个高级版本的 Iterator,单向且不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</span><br></pre></td></tr></table></figure><h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><ol><li>获取一个数据源（source）</li><li>数据转换: 执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链一样排列，变成一个管道。</li><li>终止操作</li></ol><h3 id="1、操作的数据源"><a href="#1、操作的数据源" class="headerlink" title="1、操作的数据源"></a>1、操作的数据源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title">generateListData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Employee(<span class="string">"Matt"</span>, <span class="number">5000</span>, <span class="string">"New York"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Steve"</span>, <span class="number">6000</span>, <span class="string">"London"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Steve"</span>, <span class="number">7800</span>, <span class="string">"Shanghai"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Carrie"</span>, <span class="number">10000</span>, <span class="string">"New York"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Peter"</span>, <span class="number">7000</span>, <span class="string">"New York"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Alec"</span>, <span class="number">6000</span>, <span class="string">"London"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Sarah"</span>, <span class="number">8000</span>, <span class="string">"London"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Rebecca"</span>, <span class="number">4000</span>, <span class="string">"New York"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Pat"</span>, <span class="number">20000</span>, <span class="string">"New York"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Tammy"</span>, <span class="number">9000</span>, <span class="string">"New York"</span>),</span><br><span class="line">             <span class="keyword">new</span> Employee(<span class="string">"Fred"</span>, <span class="number">15000</span>, <span class="string">"Tokyo"</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-1、过滤（筛选与切片）"><a href="#2-1、过滤（筛选与切片）" class="headerlink" title="2.1、过滤（筛选与切片）"></a>2.1、过滤（筛选与切片）</h3><table><thead><tr><th>方法</th><th>示意</th></tr></thead><tbody><tr><td>filter</td><td>接收Lambda表达式，从流中排除某些元素</td></tr><tr><td>distinct</td><td>返回包含唯一元素的流（唯一性取决于元素相等的实现方式）,例如通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td></tr><tr><td>limit</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip</td><td>返回一个丢弃前n个元素的流</td></tr></tbody></table><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@Description</span>: 过滤工资大于8000的所有员工</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       List&lt;Employee&gt; results = generateListData();</span><br><span class="line">       <span class="comment">//old</span></span><br><span class="line">       List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (Employee employee : results)&#123;</span><br><span class="line">           <span class="keyword">if</span>(employee.getSalary() &gt; <span class="number">8000</span>)&#123;</span><br><span class="line">               list.add(employee);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//new 1</span></span><br><span class="line">       List&lt;Employee&gt; collect = results.stream().filter(employee -&gt; (employee.getSalary() &gt; <span class="number">8000</span>))</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//new 2</span></span><br><span class="line">       List&lt;Employee&gt; collect1 = results.stream().filter(employee -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (employee.getSalary() &gt; <span class="number">8000</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    Employee(name&#x3D;Carrie pit, salary&#x3D;10000, office&#x3D;New York), </span><br><span class="line">    Employee(name&#x3D;Pat, salary&#x3D;20000, office&#x3D;New York),</span><br><span class="line">    Employee(name&#x3D;Tammy, salary&#x3D;9000, office&#x3D;New York), </span><br><span class="line">    Employee(name&#x3D;Fred, salary&#x3D;15000, office&#x3D;Tokyo)]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-2、映射"><a href="#2-2、映射" class="headerlink" title="2.2、映射"></a>2.2、映射</h3><table><thead><tr><th>方法</th><th>示意</th><th>应用</th></tr></thead><tbody><tr><td>map</td><td>应用于单个元素，将其映射成新元素（传递一个函数对象作为方法，把流中的元素转换成另一种类型）</td><td>map生成的是个一对一映射，比较常用</td></tr><tr><td>flatMap</td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td><td>flatMap生成一个一对多映射</td></tr></tbody></table><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; results = generateListData();</span><br><span class="line">        <span class="comment">//old</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : results)&#123;</span><br><span class="line">            <span class="keyword">if</span>(employee.getSalary() &gt; <span class="number">8000</span>)&#123;</span><br><span class="line">                list.add(employee.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new 1</span></span><br><span class="line">        List&lt;String&gt; collect = results.stream()</span><br><span class="line">                <span class="comment">//过滤</span></span><br><span class="line">                .filter(employee -&gt; (employee.getSalary() &gt; <span class="number">8000</span>))</span><br><span class="line">                <span class="comment">//转化映射</span></span><br><span class="line">                .map(employee -&gt; employee.getName()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new 2</span></span><br><span class="line">        List&lt;String&gt; collect1 = results.stream()</span><br><span class="line">                <span class="comment">//过滤</span></span><br><span class="line">                .filter(employee -&gt; (employee.getSalary() &gt; <span class="number">8000</span>))</span><br><span class="line">                <span class="comment">//转化映射</span></span><br><span class="line">                .map(Employee::getName).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Carrie pit, Pat, Tammy, Fred]</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   　* <span class="doctag">@Description</span>: map 和 flatMap</span></span><br><span class="line"><span class="comment">   　* <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">   　* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;Employee&gt; results = generateListData();</span><br><span class="line">       <span class="comment">//返回类型不一样</span></span><br><span class="line">       List&lt;String&gt; collect = results.stream().</span><br><span class="line">               <span class="comment">//每一个对象映射为名字(名字数组进一步处理为流对象)</span></span><br><span class="line">               flatMap(employee -&gt; Arrays.stream(employee.getName().split(<span class="string">" "</span>)))</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect);</span><br><span class="line"></span><br><span class="line">       List&lt;Stream&lt;String&gt;&gt; collect1 = results.stream().</span><br><span class="line">               map(employee -&gt; Arrays.stream(employee.getName().split(<span class="string">" "</span>)))</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//--------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//实现1</span></span><br><span class="line">       List&lt;String&gt; collect2 = results.stream()</span><br><span class="line">               .map(employee -&gt; (employee.getName().split(<span class="string">" "</span>)))</span><br><span class="line">               .flatMap(Arrays::stream)</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect2);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//实现1</span></span><br><span class="line">       List&lt;String&gt; collect3 = results.stream()</span><br><span class="line">               <span class="comment">//返回多个list</span></span><br><span class="line">               .map(employee -&gt; (employee.getName().split(<span class="string">" "</span>)))</span><br><span class="line">               <span class="comment">//将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line">               .flatMap(str -&gt; Arrays.asList(str).stream())</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map和flatMap的区别：flatMap的可以处理更深层次的数据，入参为多个list，结果可以返回为一个list，而map是一对一的，入参是多个list，结果返回必须是多个list。通俗的说，如果入参都是对象，那么flatMap可以操作对象里面的对象，而map只能操作第一层。</span><br></pre></td></tr></table></figure><h3 id="3、Collectors（返回流操作完之后的结果）"><a href="#3、Collectors（返回流操作完之后的结果）" class="headerlink" title="3、Collectors（返回流操作完之后的结果）"></a>3、Collectors（返回流操作完之后的结果）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect方法是一个结束操作，它可以使流里面的所有元素聚集到汇总结果。传递给collect方法参数是一个java.util.stream.Collector类型的对象。Collector对象实际上定义了一个如何把流中的元素聚集到最终结果的方法。(?).collect(Collectors.?)</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>示意</th></tr></thead><tbody><tr><td>toList</td><td>转化为List</td></tr><tr><td>toSet</td><td>转化为Set</td></tr><tr><td>toMap</td><td>转化为Map</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Employee&gt; employees = generateListData();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//toList</span></span><br><span class="line">       List&lt;String&gt; collect = employees.stream()</span><br><span class="line">               .map(Employee::getName)</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">       System.out.println(collect);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//toSet</span></span><br><span class="line">       Set&lt;String&gt; collect1 = employees.stream()</span><br><span class="line">               .map(Employee::getName)</span><br><span class="line">               .collect(Collectors.toSet());</span><br><span class="line">       System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//toMap</span></span><br><span class="line">       Map&lt;String, Employee&gt; map1 = employees.stream()</span><br><span class="line">               .collect(Collectors.toMap((key-&gt;key.getName()), (Person -&gt; Person)));</span><br><span class="line">       Map&lt;String, Integer&gt; map2 = employees.stream()</span><br><span class="line">               .collect(Collectors.toMap((key-&gt;key.getName()), (Person -&gt; Person.getSalary())));</span><br><span class="line"></span><br><span class="line">       map1.forEach((key,value) -&gt; System.out.println(<span class="string">"key:"</span> + key + <span class="string">"   value:"</span>+ value));</span><br><span class="line">       map2.forEach((key,value) -&gt; System.out.println(<span class="string">"key:"</span> + key + <span class="string">"   value:"</span>+ value));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional类主要解决的问题是臭名昭著的空指针异常（NullPointerException）—— 每个Java程序员都非常了解的异常。</span><br><span class="line">本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>示意</th></tr></thead><tbody><tr><td>Optional.of(T)</td><td>T为非空，否则初始化报错。你应该明确对象T不为null的时候使用 of()</td></tr><tr><td>Optional.ofNullable(T)</td><td>T为任意，可以为空。如果对象T即可能是null也可能是非null,你就应该使用ofNullable()方法：</td></tr><tr><td>isPresent()</td><td>等价于 !=null</td></tr><tr><td>ifPresent(T)</td><td>T可以是一段lambda表达式 ，或者其他代码，非空则执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setName(<span class="string">"oyj"</span>);</span><br><span class="line">        <span class="comment">//of(T),T为非空值</span></span><br><span class="line">        Optional&lt;Employee&gt; emp = Optional.of(employee);</span><br><span class="line">        System.out.println(emp.isPresent()?emp.get():<span class="string">"emp对象为空"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ofNullable(T),T为任意值</span></span><br><span class="line">        Optional&lt;String&gt; name = Optional.ofNullable(employee.getName());</span><br><span class="line">        <span class="comment">//name!=null输出name;否则输出"name值是空的"</span></span><br><span class="line">        System.out.println(name.isPresent()?name.get():<span class="string">"name值是空的"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不为空则打印,ifPresent(T),T可以是一段lambda表达式,或者其他代码，非空则执行</span></span><br><span class="line">        Optional.ofNullable(<span class="string">"oyj"</span>).ifPresent(x-&gt;&#123;</span><br><span class="line">            System.out.println(x+<span class="string">" isPresent"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在optional为空值的情况下orElse和orElseGet都会执行，</span></span><br><span class="line">        <span class="comment">//当optional不为空时，orElse()方法仍然执行,orElseGet()不会执行。</span></span><br><span class="line">        <span class="comment">//在执行较密集的调用时，比如调用Web服务或数据查询，这个差异会对性能产生重大影响。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果为null，则返回指定的字符串</span></span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="keyword">null</span>).orElse(<span class="string">"为空"</span>));</span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="string">"oyj"</span>).orElse(<span class="string">"为空"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果为null，则返回指定的方法</span></span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="keyword">null</span>).orElseGet(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hahahah"</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="number">1</span>).orElseGet(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java中的流式编程——Stream-API&quot;&gt;&lt;a href=&quot;#java中的流式编程——Stream-API&quot; class=&quot;headerlink&quot; title=&quot;java中的流式编程——Stream API&quot;&gt;&lt;/a&gt;java中的流式编程——Stream A
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Stream" scheme="http://yoursite.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>挑战Redis系列(1)——协议</title>
    <link href="http://yoursite.com/2020/09/07/Redis%E7%B3%BB%E5%88%971/"/>
    <id>http://yoursite.com/2020/09/07/Redis%E7%B3%BB%E5%88%971/</id>
    <published>2020-09-07T15:29:56.000Z</published>
    <updated>2020-09-09T07:56:54.588Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RESP(REdis Serialization Protocol),也就是专门为redis设计的一套序列化协议. 这个协议其实在redis的1.2版本时就已经出现了,但是到了redis2.0才最终成为redis通讯协议的标准</span><br></pre></td></tr></table></figure><h2 id="Redis通讯协议（TCP层）"><a href="#Redis通讯协议（TCP层）" class="headerlink" title="Redis通讯协议（TCP层）"></a>Redis通讯协议（TCP层）</h2><table><thead><tr><th>特点</th><th>为什么</th></tr></thead><tbody><tr><td>二进制安全的</td><td>不需要处理从一个进程传输到另一个进程的批量数据，因为它使用前缀长度来传输批量数据。</td></tr><tr><td>可读性高</td><td>简单</td></tr><tr><td>快速解析</td><td>简单</td></tr><tr><td>易于实现</td><td>简单</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:此处概述的协议仅用于客户端 - 服务器通信。 Redis Cluster使用不同的二进制协议，以便在节点之间交换消息。</span><br></pre></td></tr></table></figure><h2 id="RESP数据类型"><a href="#RESP数据类型" class="headerlink" title="RESP数据类型"></a>RESP数据类型</h2><p>Redis协议将传输的结构数据分为5种类型，第一个字节的符号来表示不同的数据类型,单元结束时统一加上回车换行符号 \r\n。</p><table><thead><tr><th>类型</th><th>标识符</th><th>形式</th><th>例子</th></tr></thead><tbody><tr><td>简单字符串（simple string）</td><td>+</td><td>放在第一个字节</td><td>“+OK\r\n”</td></tr><tr><td>错误消息（error）</td><td>-</td><td>放在第一个字节</td><td>“-ERR unknown command ‘foobar’\r\n”</td></tr><tr><td>长字符串（bulk string）&lt;512M</td><td>$</td><td>放在第一个字节，后面跟字符串的长度</td><td>“$0\r\n”   –$后面的0表示这是一个空字符串</td></tr><tr><td>整型数字（integer）</td><td>:</td><td>放在第一个字节，后面跟整形的字符串</td><td>“:1000\r\n”</td></tr><tr><td>数组（arrays）</td><td>*</td><td>放在第一个字节，后面跟数组的长度</td><td>“<em>0\r\n”   –</em>后面的0表示表示空的数组</td></tr></tbody></table><h3 id="简单字符串"><a href="#简单字符串" class="headerlink" title="简单字符串"></a>简单字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simple string 的第一个字节是个&quot;+&quot;(加号), 后面接着的是字符串的内容, 最后以CRLF(\r\n)结尾.例如:</span><br><span class="line">&quot;+hello world\r\n&quot;</span><br></pre></td></tr></table></figure><h3 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error其实和string是类似的, 但是RESP为了能让不同客户端把这种error和正常的返回结果区分开来对待 (例如redis返回error的话,就抛出异常),特意多设计了这个数据类型。error类型的第一个字节是&quot;-&quot;(减号), 后面接着的是错误的信息, 最后以CRLF(\r\n)结尾,例如:</span><br><span class="line">-ERR unknown command &#39;sets&#39;\r\n&quot;</span><br></pre></td></tr></table></figure><h3 id="长字符串"><a href="#长字符串" class="headerlink" title="长字符串"></a>长字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本质上也是字符串,跟普通字符串区分开来, 它的第一个字节是&quot;$&quot;(美元符号),紧接着是一个整数,表示字符串的字节数,字节数后面接一个CRLF. CRLF后面是字符串的内容, 最后以一个CRLF结尾. 例如:</span><br><span class="line"></span><br><span class="line">&quot;$0\r\n&quot;   --$后面的0表示这是一个空字符串</span><br><span class="line"></span><br><span class="line">&quot;$-1\r\n&quot;  -- $后面的-1表示这是一个null字符串,Null Bulk String要求客户端返回空对象,而不能简单地返回个空字符串</span><br><span class="line"></span><br><span class="line">&quot;$\r\n6ABCDEF\r\n&quot;  -- ABCDEF是6个字节,所以$后面是6</span><br></pre></td></tr></table></figure><h3 id="整型数字"><a href="#整型数字" class="headerlink" title="整型数字"></a>整型数字</h3><p>“:29\r\n”</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第一个字节是&quot;*&quot;(星号), 紧接着后面是一个数字,表示这个数组的长度,数字后面是一个CRLF. 需要注意的是这个CRLF之后才是数组的真正内容, 而且数组内容可以是任意类型, 包括arrays和bulk string, 每个元素也要以CRLF结尾. 最后以CRLF(\r\n)结尾. 例如:</span><br><span class="line"></span><br><span class="line">&quot;*0\r\n&quot;   --*后面的0表示表示空的数组</span><br><span class="line"></span><br><span class="line">&quot;*-1\r\n&quot;  --*后面的-1表示表示是null数组</span><br><span class="line"></span><br><span class="line">&quot;*5\r\n     -- *5表示这是一个拥有5个元素的数组</span><br><span class="line">+bar\r\n    -- 第1个元素是简单的字符串</span><br><span class="line">-unknown command\r\n      -- 第2个元素是个异常</span><br><span class="line">:3\r\n      -- 第3个元素是个整数</span><br><span class="line">$3\r\n      -- 第4个元素是长度为3个字节的长字符串foo</span><br><span class="line">foo\r\n     -- 第4个元素的内容</span><br><span class="line">*3\r\n      -- 第5个元素又是个数组</span><br><span class="line">:1\r\n      -- 第5个元素数组的第1元素</span><br><span class="line">:2\r\n      -- 第5个元素数组的第2元素</span><br><span class="line">:3\r\n      -- 第5个元素数组的第3元素</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure><h2 id="request-response模型"><a href="#request-response模型" class="headerlink" title="request-response模型"></a>request-response模型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. redis发送一个命令到服务端（一般组装成bulk string的数组）, 然后阻塞在socket.read()方法, 等待服务端的返回</span><br><span class="line">2. 服务端收到一个命令, 处理完成后将数据发送回去给客户端</span><br></pre></td></tr></table></figure><p>redis的大部分命令都是使用这种request-response模型进行通讯, 除了以下两种特殊的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. pipeline模式. 在pipeline模式下, 客户端可能会把多个命令收集在一起, 然后一并发送给服务端, 最后等待服务端把所有命令的执行响应一并发送回来</span><br><span class="line">2. pub&#x2F;sub, 发布订阅模式下, redis客户端只需要发送一次订阅命令</span><br></pre></td></tr></table></figure><h2 id="测试和验证"><a href="#测试和验证" class="headerlink" title="测试和验证"></a>测试和验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: RedisClient</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 撸一个简单的客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OutputStream write;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InputStream read;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line">        write = socket.getOutputStream();</span><br><span class="line">        read = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">while</span> (scan.hasNextLine()) &#123;</span><br><span class="line">            String str = scan.nextLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造协议</span></span><br><span class="line">            String commannd = buildCommand(str);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"发送命令为：\r\n"</span> + commannd);</span><br><span class="line"></span><br><span class="line">            String result = sendCommand(commannd);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"响应命令为："</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@Description</span>: 发送协议到客户端</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">sendCommand</span><span class="params">(String command)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write.write(command.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        read.read(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(bytes,<span class="string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@Description</span>: 构建RESP协议</span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">    　* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">buildCommand</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(str)) &#123;</span><br><span class="line">            String[] strs = str.split(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            builder.append(<span class="string">"*"</span>).append(strs.length).append(<span class="string">"\r\n"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String str1 : strs) &#123;</span><br><span class="line">                builder.append(<span class="string">"$"</span>).append(str1.length()).append(<span class="string">"\r\n"</span>);</span><br><span class="line">                builder.append(str1).append(<span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> builder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Git基础</title>
    <link href="http://yoursite.com/2020/09/04/Git%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/09/04/Git%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-04T09:03:45.000Z</published>
    <updated>2020-09-08T09:52:46.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git基础一"><a href="#Git基础一" class="headerlink" title="Git基础一"></a>Git基础一</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><h3 id="四个区五个状态-——-五种状态间的撤销操作"><a href="#四个区五个状态-——-五种状态间的撤销操作" class="headerlink" title="四个区五个状态  —— 五种状态间的撤销操作"></a>四个区五个状态  —— 五种状态间的撤销操作</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><table><thead><tr><th>区</th><th>名称</th></tr></thead><tbody><tr><td>工作区</td><td>Working Area</td></tr><tr><td>暂存区</td><td>Stage</td></tr><tr><td>本地仓库</td><td>Local Repository</td></tr><tr><td>远程仓库</td><td>Remote Repository</td></tr></tbody></table><table><thead><tr><th>状态</th><th>名称</th></tr></thead><tbody><tr><td>未修改</td><td>UnModified</td></tr><tr><td>已修改</td><td>Modified</td></tr><tr><td>已暂存</td><td>Staged</td></tr><tr><td>已提交</td><td>Remote Repository</td></tr></tbody></table><h4 id="1-已经修改，但还未暂存（还没有执行-git-add）"><a href="#1-已经修改，但还未暂存（还没有执行-git-add）" class="headerlink" title="1. 已经修改，但还未暂存（还没有执行 git add）"></a>1. 已经修改，但还未暂存（还没有执行 git add）</h4><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>git diff</td><td>检查的是工作区与暂存区之间的差异</td></tr><tr><td>git checkout</td><td>撤销项目下所有的修改</td></tr><tr><td>git clean -f</td><td>撤销新增的文件</td></tr><tr><td>git clean -df</td><td>撤销新增的文件和文件夹</td></tr></tbody></table><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><h4 id="2-已经修改，但还未提交（还没有执行-git-commit）"><a href="#2-已经修改，但还未提交（还没有执行-git-commit）" class="headerlink" title="2. 已经修改，但还未提交（还没有执行 git commit）"></a>2. 已经修改，但还未提交（还没有执行 git commit）</h4><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>git diff –cached</td><td>检查的是暂存区和本地仓库的差异</td></tr><tr><td>git reset</td><td>暂存区的修改恢复到工作区,即当前暂存区不存在最新的内容</td></tr><tr><td>git reset –soft</td><td>与git reset等价，回到已修改状态，修改的内容仍然在工作区中</td></tr><tr><td>git reset –hard</td><td>回到未修改状态，清空暂存区和工作区</td></tr></tbody></table><h4 id="必须先执行git-reset-git-reset-–soft，否则无法撤销修改"><a href="#必须先执行git-reset-git-reset-–soft，否则无法撤销修改" class="headerlink" title="必须先执行git reset = git reset –soft，否则无法撤销修改"></a>必须先执行git reset = git reset –soft，否则无法撤销修改</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="4.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="5.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><h4 id="通过git-reset-git-checkout-命令-gt-取消了工作区的修改，此时工作区的内容回退到了修改之前（hello-world-gt-123456uuu12）"><a href="#通过git-reset-git-checkout-命令-gt-取消了工作区的修改，此时工作区的内容回退到了修改之前（hello-world-gt-123456uuu12）" class="headerlink" title="通过git reset + git checkout 命令-&gt;取消了工作区的修改，此时工作区的内容回退到了修改之前（hello world -&gt; 123456uuu12）"></a>通过git reset + git checkout 命令-&gt;取消了工作区的修改，此时工作区的内容回退到了修改之前（hello world -&gt; 123456uuu12）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="6.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="7.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><h4 id="回到未修改状态，清空暂存区和工作区，此时工作区的内容回退到了修改之前（123-gt-hello-word123），彻底还原到上一次提交的状态且无法找回"><a href="#回到未修改状态，清空暂存区和工作区，此时工作区的内容回退到了修改之前（123-gt-hello-word123），彻底还原到上一次提交的状态且无法找回" class="headerlink" title="回到未修改状态，清空暂存区和工作区，此时工作区的内容回退到了修改之前（123 -&gt; hello word123），彻底还原到上一次提交的状态且无法找回"></a>回到未修改状态，清空暂存区和工作区，此时工作区的内容回退到了修改之前（123 -&gt; hello word123），彻底还原到上一次提交的状态且无法找回</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &#x3D; git reset + git checkout</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="8.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><h4 id="清空（不是删除所有内容，而是回退到修改之前的暂存区内容）"><a href="#清空（不是删除所有内容，而是回退到修改之前的暂存区内容）" class="headerlink" title="清空（不是删除所有内容，而是回退到修改之前的暂存区内容）"></a>清空（不是删除所有内容，而是回退到修改之前的暂存区内容）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="9.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><h4 id="3-已提交，未推送"><a href="#3-已提交，未推送" class="headerlink" title="3. 已提交，未推送"></a>3. 已提交，未推送</h4><p>执行完commit之后，会在仓库中生成一个版本号(hash值)，标志这次提交。之后任何时候，都可以借助这个hash值<br>回退到这次提交。</p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>git diff master origin/master</td><td>查看本地仓库与本地远程仓库的差异</td></tr><tr><td>git reset –hard HEAD^</td><td>回退到本地仓库上一个版本</td></tr><tr><td>git reset –hard <hash code></td><td>回退到任意版本</td></tr><tr><td>git reset –soft/git reset</td><td>回退且回到已修改状态，修改仍保留在工作区中</td></tr></tbody></table><h4 id="4-已推送到远程"><a href="#4-已推送到远程" class="headerlink" title="4. 已推送到远程"></a>4. 已推送到远程</h4><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>git push -f orgin master</td><td>强制覆盖远程分支</td></tr><tr><td>git push -f</td><td>如果之前已经用 -u 关联过，则可省略分支名</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先，先用git status查看下当前状态。</span><br><span class="line"></span><br><span class="line">git reset可以作用于本地仓库，用于回退&#x2F;前进到任意版本，也可以作用于暂存区，用于撤销暂存区修改。有hard和soft2个参数。soft参数可以省略，soft参数表示撤销的修改仍放在工作区中。</span><br><span class="line"></span><br><span class="line">git checkout用于撤销删除和修改，git clean用于撤销新增。</span><br><span class="line"></span><br><span class="line">git diff可以查看工作区、暂存区、仓库之间的修改和差异，参数不同。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git基础一&quot;&gt;&lt;a href=&quot;#Git基础一&quot; class=&quot;headerlink&quot; title=&quot;Git基础一&quot;&gt;&lt;/a&gt;Git基础一&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="http://yoursite.com/2019/07/11/HashMap/"/>
    <id>http://yoursite.com/2019/07/11/HashMap/</id>
    <published>2019-07-11T03:14:24.000Z</published>
    <updated>2020-07-30T14:28:02.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h2><ol><li><p>默认的常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 HashMap 时未指定初始容量情况下的默认容量  16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="comment">//HashMap 的最大容量 2^30 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//HashMap 默认的装载因子,当 HashMap 中元素数量超过容量装载因子时，进行　resize()　操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; </span><br><span class="line"><span class="comment">//链表转红黑树的阈值 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line"><span class="comment">//用来确定何时将解决 hash 冲突的红黑树转变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p>存储结构<br>内部包含了一个 Node 类型的数组 table。观察 Node 可以发现table是一个链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>Node 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 table 是一个链表。即数组中的每个位置被当<br>成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结<br>果相同的 Ndoe.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//保存节点的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key;<span class="comment">//保存节点的key值</span></span><br><span class="line">    V value;<span class="comment">//保存节点的value值</span></span><br><span class="line">    Node&lt;K,V&gt; next;<span class="comment">//指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 存储当前节点的父节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;　<span class="comment">//存储当前节点的左孩子</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;　<span class="comment">//存储当前节点的右孩子</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// 存储当前节点的前一个节点</span></span><br><span class="line">        <span class="keyword">boolean</span> red;　<span class="comment">// 存储当前节点的颜色（红、黑）</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap的结构<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1563864906121.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br></li></ol><ol start="4"><li>拉链法的工作原理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"K1"</span>, <span class="string">"V1"</span>);</span><br><span class="line">map.put(<span class="string">"K2"</span>, <span class="string">"V2"</span>);</span><br><span class="line">map.put(<span class="string">"K3"</span>, <span class="string">"V3"</span>);</span><br></pre></td></tr></table></figure>. 新建一个 HashMap，默认大小为 16；<br><br>. 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。<br><br>. 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。<br><br>. 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在&lt;K2,V2&gt; 前面。<br><br>注意：应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头<br>部<br></li></ol><p>查找需要分成两步进行：<br>计算键值对所在的桶；<br>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</p><ol start="5"><li>put操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，<br>那么就可以将这个操作转换为位运算。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下<br>标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125; </span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>扩容-基本原理<br>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长<br>度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。<br>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。<br>HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。<br>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1563867424345345.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">//键值对的数量size大于threshold时进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">    <span class="comment">//扩容使用resize()实现</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此<br>这一步是很费时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>扩容-重新计算桶下标<br>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。<br>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：<br><br>capacity     : 00010000<br><br>new capacity : 00100000<br>对于一个 Key，</li></ol><p>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；<br>如果为 1，那么得到的结果为原来的结果 +16。</p><ol start="8"><li>计算数组容量<br>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。<br></li></ol><p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mask |&#x3D; mask &gt;&gt; 1 11011000</span><br><span class="line">mask |&#x3D; mask &gt;&gt; 2 11111110</span><br><span class="line">mask |&#x3D; mask &gt;&gt; 4 11111111</span><br></pre></td></tr></table></figure><ol start="8"><li>链表转红黑树<br>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap源码解析&quot;&gt;&lt;a href=&quot;#HashMap源码解析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码解析&quot;&gt;&lt;/a&gt;HashMap源码解析&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;默认的常量&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="集合" scheme="http://yoursite.com/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="源码阅读" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>java内存模型</title>
    <link href="http://yoursite.com/2019/07/10/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/07/10/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-07-10T03:14:24.000Z</published>
    <updated>2020-07-30T14:28:02.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA内存模型（Jave-Memory-Model-JMM）"><a href="#JAVA内存模型（Jave-Memory-Model-JMM）" class="headerlink" title="JAVA内存模型（Jave Memory Model:JMM）"></a>JAVA内存模型（Jave Memory Model:JMM）</h3><h4 id="一、CPU和内存的交互"><a href="#一、CPU和内存的交互" class="headerlink" title="一、CPU和内存的交互"></a>一、CPU和内存的交互</h4><p>在计算机中，cpu和内存的交互最为频繁，但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种CPU与内存间的速度不匹配问题情况。cpu和内存的交互大致如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2019071002.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="二、多核CPU多级缓存一致性协议MESI"><a href="#二、多核CPU多级缓存一致性协议MESI" class="headerlink" title="二、多核CPU多级缓存一致性协议MESI"></a>二、多核CPU多级缓存一致性协议MESI</h4><p>多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致性,不让系统数据混乱。这里就引出了一个一致性的协议MESI。<br>CPU中每个缓存行（caceh line)使用4种状态进行标记（使用额外的两位(bit)表示):<br></p><p>M: 被修改（Modified)<br></p><p>该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。</p><p>当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态。<br></p><p>E: 独享的（Exclusive)<br></p><p>该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。</p><p>同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态。<br></p><p>S: 共享的（Shared)<br></p><p>该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））。<br></p><p>I: 无效的（Invalid）<br></p><p>该缓存是无效的（可能有其它CPU修改了该缓存行）。<br></p><h4 id="三、什么是JMM？"><a href="#三、什么是JMM？" class="headerlink" title="三、什么是JMM？"></a>三、什么是JMM？</h4><p>JMM即为JAVA 内存模型（java memory model）。因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。<br><br>Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。<br><br>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。<br><br>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）<br><br>本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2019071001.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><h4 id="四、java内存模型抽象结构图"><a href="#四、java内存模型抽象结构图" class="headerlink" title="四、java内存模型抽象结构图"></a>四、java内存模型抽象结构图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2019071003.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><p>JMM（java memory model）java内存模型主要目标是定义程序中的变量，（此处所指的变量是实例字段、静态字段等，不包含局部变量和函数参数，因为这两种是线程私有且无法共享）<br><br>在虚拟机中规定了存储到内存与从内存读取出来的5规则细节，Java 内存模型规定所有变量都存储在主内存中，每条线程还有自己的工作内存，工作内存保存了该线程使用到的变量（主内存副本拷贝），线程对变量的所有操作（读取、赋值）都必须在自己的工作内存中进行而不能直接读写主内存的变量，不同线程之间无法相互直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2019071005.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br><p>Java 内存模型对主内存与工作内存之间的具体交互协议定义了八种操作，具体如下：</p><ol><li><p>lock（锁定）：作用于主内存变量，把一个变量标识为一条线程独占状态。</p></li><li><p>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</p></li><li><p>read（读取）：作用于主内存变量，把一个变量从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</p></li><li><p>load（载入）：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p></li><li><p>use（使用）：作用于工作内存变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时执行此操作。</p></li><li><p>assign（赋值）：作用于工作内存变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个需要给变量进行赋值的字节码指令时执行此操作。</p></li><li><p>store（存储）：作用于工作内存变量，把工作内存中一个变量的值传递到主内存中，以便后续 write 操作。</p></li><li><p>write（写入）：作用于主内存变量，把 store 操作从工作内存中得到的值放入主内存变量中。<br><br>br</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2019071004.png" alt="avatar" title="">                </div>                <div class="image-caption">avatar</div>            </figure><br></li></ol><p>如果要把一个变量从主内存复制到工作内存就必须按顺序执行 read 和 load 操作，从工作内存同步回主内存就必须顺序执行 store 和 write 操作<br><br>但是 JVM 只要求了操作的顺序而没有要求上述操作必须保证连续性，所以实质执行中 read 和 load 间及 store 和 write 间是可以插入其他指令的。<br></p><p>其实 Java JMM 内存模型是围绕并发编程中原子性、可见性、有序性三个特征来建立的，关于原子性、可见性、有序性的理解如下：</p><p>原子性：就是说一个操作不能被打断，要么执行完要么不执行，类似事务操作，Java 基本类型数据的访问大都是原子操作，long 和 double 类型是 64 位，在 32 位 JVM 中会将 64 位数据的读写操作分成两次 32 位来处理，所以 long 和 double 在 32 位 JVM 中是非原子操作，也就是说在并发访问时是线程非安全的，要想保证原子性就得对访问该数据的地方进行同步操作，譬如 <font color="red">synchronized</font> 等。</p><p>可见性：就是说当一个线程对共享变量做了修改后其他线程可以立即感知到该共享变量的改变，从 Java 内存模型我们就能看出来多线程访问共享变量都要经过线程工作内存到主存的复制和主存到线程工作内存的复制操作，所以普通共享变量就无法保证可见性了；<font color="red">Java 提供了 volatile 修饰符来保证变量的可见性，每次使用 volatile 变量都会主动从主存中刷新，除此之外 synchronized、Lock、final 都可以保证变量的可见性。</font></p><p>有序性：就是说 Java 内存模型中的指令重排不会影响单线程的执行顺序，但是会影响多线程并发执行的正确性，所以在并发中我们必须要想办法保证并发代码的有序性；<font color="red">在 Java 里可以通过 volatile 关键字保证一定的有序性，还可以通过 synchronized、Lock 来保证有序性</font>，因为 synchronized、Lock 保证了每一时刻只有一个线程执行同步代码相当于单线程执行，所以自然不会有有序性的问题；除此之外 Java 内存模型通过 happens-before 原则如果能推导出来两个操作的执行顺序就能先天保证有序性，否则无法保证，关于 happens-before 原则可以查阅相关资料。</p><p>所以说如果想让 Java 并发程序正确的执行必须保证原子性、有序性、可见性，只要三者中有任意一个不满足并发都无法正确执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA内存模型（Jave-Memory-Model-JMM）&quot;&gt;&lt;a href=&quot;#JAVA内存模型（Jave-Memory-Model-JMM）&quot; class=&quot;headerlink&quot; title=&quot;JAVA内存模型（Jave Memory Model:JMM
      
    
    </summary>
    
    
      <category term="java技术" scheme="http://yoursite.com/categories/java%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java内存" scheme="http://yoursite.com/tags/java%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>hexo的使用</title>
    <link href="http://yoursite.com/2018/11/07/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/07/hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-11-07T07:55:28.000Z</published>
    <updated>2020-09-04T09:10:20.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hexo部署命令的使用"><a href="#Hexo部署命令的使用" class="headerlink" title="Hexo部署命令的使用"></a>Hexo部署命令的使用</h3><ol><li>在source_posts文件夹下创建一个新的md文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;***&quot;</span><br></pre></td></tr></table></figure></li><li>在public文件夹下面生成静态文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate 或者 hexo g</span><br></pre></td></tr></table></figure></li><li>启动本地服务，先观察部署的md文件是否生效<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server 或者 hexo s</span><br></pre></td></tr></table></figure></li><li>观察无误后，可以进行网站的部署<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy 或者 hexo d</span><br></pre></td></tr></table></figure></li></ol><hr><ol start="5"><li><em>public静态文件的清理命令</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hexo部署命令的使用&quot;&gt;&lt;a href=&quot;#Hexo部署命令的使用&quot; class=&quot;headerlink&quot; title=&quot;Hexo部署命令的使用&quot;&gt;&lt;/a&gt;Hexo部署命令的使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在source_posts文件夹下创建一个新的md文件&lt;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Blog" scheme="http://yoursite.com/tags/Blog/"/>
    
  </entry>
  
</feed>
